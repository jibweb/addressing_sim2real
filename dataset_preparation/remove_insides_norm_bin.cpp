#include <string>
#include <unordered_map>
#include <unordered_set>

#include <boost/program_options.hpp>
#include <pcl/conversions.h>
#include <pcl/PolygonMesh.h>
#include <pcl/io/ply_io.h>
#include <pcl/visualization/cloud_viewer.h>

#include <augmentation_preprocessing.cpp>
#include <mesh_utils.cpp>

#include "tinyply.h"

using namespace tinyply;
namespace po = boost::program_options;

typedef pcl::PointXYZ PointT;
struct float3 { float x, y, z; };
struct uint3 { uint32_t x, y, z; };


///////////////////////////////////////////////////////////////////////////////////////////////////
void to_polygon_mesh(const pcl::PointCloud<PointT>::Ptr pc,
                     const std::vector<uint3> & triangles,
                     pcl::PolygonMesh::Ptr mesh) {
  pcl::PCLPointCloud2 point_cloud2;
  pcl::toPCLPointCloud2(*pc, point_cloud2);

  mesh->cloud = point_cloud2;
  mesh->polygons.resize(triangles.size());
  for (uint tri_idx=0; tri_idx<triangles.size(); tri_idx++) {
    mesh->polygons[tri_idx].vertices.push_back(triangles[tri_idx].x);
    mesh->polygons[tri_idx].vertices.push_back(triangles[tri_idx].y);
    mesh->polygons[tri_idx].vertices.push_back(triangles[tri_idx].z);
  }
}


void cam_rot_from_pos(Eigen::Vector3d & cam_pos,
                      Eigen::Matrix3d & cam_rot) {
  Eigen::Vector3d z;
  z << 0., 0., 1;
  cam_pos.normalize();

  Eigen::Vector3d orth_vec = -z + cam_pos.dot(z) * cam_pos;
  orth_vec.normalize();

  cam_rot.row(0) = orth_vec.cross(-cam_pos);
  cam_rot.row(1) = orth_vec;
  cam_rot.row(2) = -cam_pos;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
void savePLY(const std::string & filename,
             std::vector<float3> & pc,
             std::vector<float3> & normals,
             std::vector<uint3> & triangles) {
    std::filebuf fb_binary;
    fb_binary.open(filename, std::ios::out | std::ios::binary);
    std::ostream outstream_binary(&fb_binary);
    if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filename);

    PlyFile mesh_file;

    mesh_file.add_properties_to_element("vertex", { "x", "y", "z" },
        Type::FLOAT32, pc.size(), reinterpret_cast<uint8_t*>(pc.data()), Type::INVALID, 0);

    mesh_file.add_properties_to_element("vertex", { "nx", "ny", "nz" },
        Type::FLOAT32, normals.size(), reinterpret_cast<uint8_t*>(normals.data()), Type::INVALID, 0);

    mesh_file.add_properties_to_element("face", { "vertex_indices" },
        Type::INT32, triangles.size(), reinterpret_cast<uint8_t*>(triangles.data()), Type::UINT8, 3);

    mesh_file.get_comments().push_back("generated by tinyply 2.2");

    // Write a binary file
    mesh_file.write(outstream_binary, true);
}


///////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char* argv[]) {

  pcl::console::setVerbosityLevel(pcl::console::L_ALWAYS);

  /****************************************************************************
  * Args processing
  ****************************************************************************/
  po::options_description desc("Extract a subset of a mesh based on those visible in renderings \n");

  std::string input = "";
  std::string output = "./";
  bool viz = false;

  desc.add_options()
      ("help,h", "produce this help message")
      ("input,i", po::value<std::string>(&input)->default_value(input), "Mesh to render")
      ("output,o", po::value<std::string>(&output)->default_value(output), "Folder in which to save the point clouds")
      ("viz,v", po::value<bool>(&viz)->default_value(viz), "Enable viz");

  po::variables_map vm;
  po::parsed_options parsed = po::command_line_parser(argc, argv).options(desc).allow_unregistered().run();
  std::vector<std::string> to_pass_further = po::collect_unrecognized(parsed.options, po::include_positional);
  po::store(parsed, vm);
  if (vm.count("help"))
  {
      std::cout << desc << std::endl;
      return false;
  }

  try {po::notify(vm);}
  catch(std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl << std::endl << desc << std::endl; return false;
  }

  if ((output.size() > 0) && !(output[output.size()-1] == '/'))
      output += "/";


  /****************************************************************************
  * Setup
  ****************************************************************************/
  pcl::PolygonMesh::Ptr mesh(new pcl::PolygonMesh);
  pcl::PointCloud<PointT>::Ptr pc(new pcl::PointCloud<PointT>);

  // Read the mesh
  if (pcl::io::load(input.c_str(), *mesh) == -1) {
    PCL_ERROR("Couldn't read %s file \n", input.c_str());
    return -1;
  }

  // Transform the mesh into a point cloud
  pcl::fromPCLPointCloud2(mesh->cloud, *pc);
  scale_points_unit_sphere<PointT>(*pc, 1.);


  std::cout << "Done with Setup" << std::endl;
  /****************************************************************************
  * Extraction
  ****************************************************************************/
  std::set<uint> face_subset;
  Eigen::MatrixXi F;
  F.resize(mesh->polygons.size(), 3);

  for (uint face_idx=0; face_idx<mesh->polygons.size(); face_idx++) {
    F(face_idx, 0) = mesh->polygons[face_idx].vertices[0];
    F(face_idx, 1) = mesh->polygons[face_idx].vertices[1];
    F(face_idx, 2) = mesh->polygons[face_idx].vertices[2];
  }


  // --- VIEWS DEFS -----------------------------------------------------------
  std::vector<Eigen::Matrix3d> cams_rot;
  std::vector<Eigen::Vector3d> cams_pos;

  Eigen::Matrix3d cam_rot;
  Eigen::Vector3d cam_pos;

  // Face view
  cam_pos << -1., 0., -0.05;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);

  cam_pos << 1., 0., -0.05;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);

  cam_pos << 0., -1., -0.05;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);

  cam_pos << 0., 1., -0.05;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);


  // Angled view
  cam_pos << 1., 1., -1.;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);

  cam_pos << -1., 1., -1.;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);

  cam_pos << -1., -1., -1.;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);

  cam_pos << 1., -1., -1.;
  cam_rot_from_pos(cam_pos, cam_rot);
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);


  // Top view
  cam_rot << 0., 1., 0.,
             1., 0., 0.,
             0., 0., -1.;
  cam_pos << 0., 0., -1.;
  cams_rot.push_back(cam_rot);
  cams_pos.push_back(cam_pos);


  for (uint cam_idx=0; cam_idx < cams_rot.size(); cam_idx++) {
    // --- PROJECTION -----------------------------------------------------------
    Eigen::MatrixXd V_uv(pc->points.size(), 2);
    Eigen::VectorXd V_z(pc->points.size());

    V_uv.resize(pc->points.size(), 2);
    V_z.resize(pc->points.size());

    for (uint vertex_idx=0; vertex_idx<pc->points.size(); vertex_idx++) {
      Eigen::Vector3d p = pc->points[vertex_idx].getVector3fMap().cast<double>();
      Eigen::Vector3d proj_coords = cams_rot[cam_idx] * (p - cams_pos[cam_idx]);

      V_uv(vertex_idx, 0) = proj_coords(0);
      V_uv(vertex_idx, 1) = proj_coords(1);
      V_z(vertex_idx) = proj_coords(2);
    }

    // --- RASTERIZATION --------------------------------------------------------

    uint image_size = 700;

    Eigen::MatrixXi I_face_idx = Eigen::MatrixXi::Constant(image_size+1, image_size+1, -1);
    Eigen::MatrixXd image_mask = Eigen::MatrixXd::Constant(image_size+1, image_size+1, 0.);

    Eigen::MatrixXd W0 = Eigen::MatrixXd::Constant(image_size+1, image_size+1, 0.);
    Eigen::MatrixXd W1 = Eigen::MatrixXd::Constant(image_size+1, image_size+1, 0.);
    Eigen::MatrixXd W2 = Eigen::MatrixXd::Constant(image_size+1, image_size+1, 0.);

    double min_u = V_uv.col(0).minCoeff(), max_u = V_uv.col(0).maxCoeff();
    double min_v = V_uv.col(1).minCoeff(), max_v = V_uv.col(1).maxCoeff();
    double min_px=std::min(min_u, min_v), max_px=std::max(max_u, max_v);

    rasterize(F, V_uv, V_z, W0, W1, W2, I_face_idx, image_mask, image_size, min_px, max_px);

    for (uint i=0; i<I_face_idx.rows(); i++)
      for (uint j=0; j<I_face_idx.cols(); j++)
        if (I_face_idx(i,j) != -1)
          face_subset.insert(I_face_idx(i,j));
  }

  // --- SUBSET EXTRACTION ----------------------------------------------------
  std::unordered_set<uint> vertex_subset;

  for (auto face_idx : face_subset) {
    vertex_subset.insert(mesh->polygons[face_idx].vertices[0]);
    vertex_subset.insert(mesh->polygons[face_idx].vertices[1]);
    vertex_subset.insert(mesh->polygons[face_idx].vertices[2]);
  }

  // Re-map vertices of the subset to 0-vertices_nb to re-index the triangles properly
  std::unordered_map<uint, uint> reverse_vertex_idx;
  uint new_idx = 0;
  for (auto vertex_idx : vertex_subset) {
    reverse_vertex_idx[vertex_idx] = new_idx;
    new_idx++;
  }

  // Copy the vertices to save
  std::vector<float3> saved_struct_points(vertex_subset.size());
  uint v_idx=0;

  for (auto vertex_idx : vertex_subset) {
    saved_struct_points[v_idx].x = pc->points[vertex_idx].x;
    saved_struct_points[v_idx].y = pc->points[vertex_idx].y;
    saved_struct_points[v_idx].z = pc->points[vertex_idx].z;
    v_idx++;
  }

  // Copy the triangles to save
  std::vector<uint3> triangles;
  triangles.resize(face_subset.size());
  uint loop_idx=0;

  for (auto face_idx : face_subset) {
    triangles[loop_idx].x = reverse_vertex_idx[mesh->polygons[face_idx].vertices[0]];
    triangles[loop_idx].y = reverse_vertex_idx[mesh->polygons[face_idx].vertices[1]];
    triangles[loop_idx].z = reverse_vertex_idx[mesh->polygons[face_idx].vertices[2]];
    loop_idx++;
  }


  std::cout << "Done with Extraction" << std::endl;
  /****************************************************************************
  * Normal Computation
  ****************************************************************************/
  std::vector<Eigen::Vector3f> face_normals(triangles.size());
  std::vector<Eigen::Vector3f> vertex_normals(saved_struct_points.size(), Eigen::Vector3f::Zero());
  for (uint tri_idx=0; tri_idx<triangles.size(); tri_idx++) {
    Eigen::Vector3f p0, p1, p2;
    p0 << saved_struct_points[triangles[tri_idx].x].x,
          saved_struct_points[triangles[tri_idx].x].y,
          saved_struct_points[triangles[tri_idx].x].z;

    p1 << saved_struct_points[triangles[tri_idx].y].x,
          saved_struct_points[triangles[tri_idx].y].y,
          saved_struct_points[triangles[tri_idx].y].z;

    p2 << saved_struct_points[triangles[tri_idx].z].x,
          saved_struct_points[triangles[tri_idx].z].y,
          saved_struct_points[triangles[tri_idx].z].z;

    face_normals[tri_idx] = triangle_normal(p0, p1, p2);
    vertex_normals[triangles[tri_idx].x] += face_normals[tri_idx];
    vertex_normals[triangles[tri_idx].y] += face_normals[tri_idx];
    vertex_normals[triangles[tri_idx].z] += face_normals[tri_idx];

    if (std::isnan(face_normals[tri_idx](0)) || std::isnan(face_normals[tri_idx](1)) || std::isnan(face_normals[tri_idx](2)))
      std::cout << face_normals[tri_idx](0) << ", " << face_normals[tri_idx](1) << ", " << face_normals[tri_idx](2) << " ;; "
                << p0(0) << ", " << p0(1) << ", " << p0(2) << " ;; "
                << p1(0) << ", " << p1(1) << ", " << p1(2) << " ;; "
                << p2(0) << ", " << p2(1) << ", " << p2(2) << " || ";
  }


  std::vector<float3> saved_struct_normals(saved_struct_points.size());
  for (uint pt_idx=0; pt_idx<saved_struct_points.size(); pt_idx++) {
    Eigen::Vector3f normal = vertex_normals[pt_idx];
    normal.normalize();

    saved_struct_normals[pt_idx].x = normal(0);
    saved_struct_normals[pt_idx].y = normal(1);
    saved_struct_normals[pt_idx].z = normal(2);

    // if (std::isnan(saved_struct_normals[pt_idx].x) || std::isnan(saved_struct_normals[pt_idx].y) || std::isnan(saved_struct_normals[pt_idx].z))
    //   std::cout << saved_struct_normals[pt_idx].x << ", " << saved_struct_normals[pt_idx].y << ", " << saved_struct_normals[pt_idx].z << " ;; "
    //             << vertex_normals[pt_idx](0) << ", " << vertex_normals[pt_idx](1) << ", " << vertex_normals[pt_idx](2) << " || ";
  }


  std::cout << "Done with Normal computation" << std::endl;
  /****************************************************************************
  * Saving and Viz
  ****************************************************************************/
  std::string filename;
  for (uint i=input.size()-1; i > 0; i--)
  {
      if (input[i] == '/')
      {
          filename = input.substr(i+1, input.size() - i - 5);
          break;
      }
  }

  std::string save_filename = output + filename + "_visible_normals_bin.ply";
  std::cout << "trying to save " << save_filename << std::endl;
  savePLY(save_filename, saved_struct_points, saved_struct_normals, triangles);

  // Viz
  if (viz) {
    pcl::PointCloud<PointT>::Ptr saved_pc(new pcl::PointCloud<PointT>);
    pcl::PointCloud<pcl::Normal>::Ptr saved_normals(new pcl::PointCloud<pcl::Normal>);
    saved_pc->points.resize(saved_struct_points.size());
    saved_normals->points.resize(saved_struct_normals.size());

    for (uint pt_idx=0; pt_idx<saved_pc->points.size(); pt_idx++) {
      saved_normals->points[pt_idx].normal_x = saved_struct_normals[pt_idx].x;
      saved_normals->points[pt_idx].normal_y = saved_struct_normals[pt_idx].y;
      saved_normals->points[pt_idx].normal_z = saved_struct_normals[pt_idx].z;

      saved_pc->points[pt_idx].x = saved_struct_points[pt_idx].x;
      saved_pc->points[pt_idx].y = saved_struct_points[pt_idx].y;
      saved_pc->points[pt_idx].z = saved_struct_points[pt_idx].z;
    }

    pcl::PolygonMesh::Ptr saved_mesh(new pcl::PolygonMesh);
    to_polygon_mesh(saved_pc, triangles, saved_mesh);

    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
    viewer->setBackgroundColor (0, 0, 0);
    viewer->addCoordinateSystem (1., "coords", 0);
    viewer->addPolygonMesh (*saved_mesh);
    viewer->addPointCloudNormals<PointT, pcl::Normal> (saved_pc, saved_normals, 1, 0.05, "normals");

    while (!viewer->wasStopped()) {
      viewer->spinOnce(100);
    }
  }

  return 0;
}
